---
eip: 101
title: Serenity Currency and Crypto Abstraction
author: Vitalik Buterin <v@buterin.com>
status: Stagnant
type: Standards Track
category: Core
created: 2015-11-15
---

### 规范

1.  现在账户的RLP编码中只有两个字段: **code** and **storage**.
2.  以太坊代币不再直接存储在账户对象中；相反，在地址`0`，我们预设了一个包含所有以太坊代币持有量的合约。web3中的 "eth.getBalance "命令被适当地重新定位。
3.  `msg.value`操作代码作废。
4.  一笔交易现在只有四个字段：**to**、**startgas**、**data** 和 **code**。
5.  除了 RLP 有效性检查，并检查 **to** 字段的长度是否为 20 个字节，**startgas** 是一个整数，**code** 为空或分散到 **to**地址，没有其他有效性限制；行为均有效。但是因为区块gas限制仍然存在，矿工会拒绝含有junk的行为。
6.  *code*中字节的gas费率与*data*保持一致.
7.  当交易被发送时，如果接收账户不存在，该账户将被创建，其代码被设置为交易中提供的代码；否则，该代码将被忽略。
8.  在索引中，添加操作代码"tx.gas"到"msg.gas"旁; 这个新的操作代码允许交易访问为该交易分配的初始gas数量。请注意，ECRECOVER、序号/nonce递增和ether现在不在底层规范中
(注意:ether将继续在Casper PoS中拥有特权角色)。为了在新模型下复制现有功能，我们将执行以下操作：

一般用户帐户可以有以下默认的标准化代码:

```python
# We assume that data takes the following schema:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly called "nonce")
# bytes 128-159: gasprice
# bytes 172-191: to
# bytes 192+: data

# Get the hash for transaction signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)
# Call ECRECOVER contract to get the sender
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)
# Check sender correctness
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1
# Check sequence number correctness
assert ~calldataload(96) == self.storage[-1]
# Increment sequence number
self.storage[-1] += 1
# Make the sub-call and discard output
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)
# Pay for gas
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
```

这基本上实现了签名和随机数检查，如果两个检查都通过，那么它使用所有剩余的 gas 减去 50000 来发送实际所需的调用，然后最终支付 gas。

矿工在收到申请时可以遵循以下算法：

1.  运行最多 50000 gas 的代码，如果他们看到有可能超过此限制的操作或调用，则停止。
2.  看到该操作后，确保它至少留下 50000 个 gas 以备用（通过检查静态 gas 消耗量是否足够小或检查它是否是一个以msg.gas - 50000gas 限制参数为参数的调用）。
3.  模式匹配以确保最后的gas支付代码与上面的代码完全相同。
这个过程确保矿工在知道是否值得将交易包括在内之前最多浪费50000 gas，并且也是高度通用的，因此用户可以尝试新的密码学（例如 ed25519、Lamport）、环签名、准-native multisig 等。理论上，甚至可以创建一个帐户，其有效签名类型是收据的有效 Merkle 分支，从而创建一个准本地闹钟。
如果有人想发送一个非零值的交易，而不是目前的msg.sender方法，我们编译成一个三步过程：

1.  在调用之前的外部范围内，调用以太坊合约以创建所需金额的支票。
2.  在内部作用域中，如果合约msg.value在被调用函数的任何地方使用操作代码，那么我们让合约在函数调用开始时兑现支票，并将兑现的金额存储在内存中的标准化地址中。
3.  在调用后的外部作用域中，如果尚未兑现，则向以太坊合约发送消息以禁用支票。
### 原理解析

这使得普遍性有了很大的提高，特别是在几个领域：
1. 用于保护账户的加密算法(我们可以合理地说，以太坊是量子安全的，因为一个人可以完全自由地保护自己的账户，通过Lamport签名)。现在，nonce 递增方法也可以由账户持有人进行修订，允许在 k 可并行随机数技术、UTXO 方案等方面进行实验。
2.  Moving ether up a level of abstraction, with the particular benefit of allowing ether and sub-tokens to be treated similarly by contracts
3.  Reducing the level of indirection required for custom-policy accounts such as multisigs

It also substantially simplifies and *purifies* the underlying Ethereum protocol, reducing the minimal consensus implementation complexity.

### Implementation

Coming soon.
